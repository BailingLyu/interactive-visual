import React, { useState, useEffect } from 'react';import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, ReferenceLine } from 'recharts';import { Play, RotateCcw, Sparkles } from 'lucide-react';const SamplingDistributionViz = () => {  const [populationType, setPopulationType] = useState('normal');  const [sampleSize, setSampleSize] = useState(30);  const [numSamples, setNumSamples] = useState(0);  const [sampleMeans, setSampleMeans] = useState([]);  const [isAnimating, setIsAnimating] = useState(false);  const [currentSample, setCurrentSample] = useState([]);    const populationSize = 10000;    // Generate population based on distribution type  const generatePopulation = () => {    let pop = [];    switch(populationType) {      case 'normal':        for(let i = 0; i < populationSize; i++) {          pop.push(boxMuller() * 15 + 50);        }        break;      case 'uniform':        for(let i = 0; i < populationSize; i++) {          pop.push(Math.random() * 60 + 20);        }        break;      case 'skewed':        for(let i = 0; i < populationSize; i++) {          const val = Math.pow(Math.random(), 2) * 80 + 10;          pop.push(val);        }        break;      case 'bimodal':        for(let i = 0; i < populationSize; i++) {          if(Math.random() < 0.5) {            pop.push(boxMuller() * 10 + 30);          } else {            pop.push(boxMuller() * 10 + 70);          }        }        break;    }    return pop;  };    // Box-Muller transform for normal distribution  const boxMuller = () => {    let u = 0, v = 0;    while(u === 0) u = Math.random();    while(v === 0) v = Math.random();    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);  };    const [population] = useState(() => generatePopulation());    // Calculate population statistics  const popMean = population.reduce((a, b) => a + b, 0) / population.length;  const popVariance = population.reduce((sum, val) => sum + Math.pow(val - popMean, 2), 0) / population.length;  const popStd = Math.sqrt(popVariance);    // Create histogram data for population  const getPopulationHistogram = () => {    const bins = 40;    const min = Math.min(...population);    const max = Math.max(...population);    const binWidth = (max - min) / bins;    const hist = new Array(bins).fill(0);        population.forEach(val => {      const binIndex = Math.min(Math.floor((val - min) / binWidth), bins - 1);      hist[binIndex]++;    });        return hist.map((count, i) => ({      value: min + (i + 0.5) * binWidth,      count: count / population.length * 100    }));  };    // Create histogram data for sample means  const getSampleMeansHistogram = () => {    if(sampleMeans.length === 0) return [];        const bins = 30;    const min = Math.min(...sampleMeans);    const max = Math.max(...sampleMeans);    const binWidth = Math.max((max - min) / bins, 0.1);    const hist = new Array(bins).fill(0);        sampleMeans.forEach(val => {      const binIndex = Math.min(Math.floor((val - min) / binWidth), bins - 1);      hist[binIndex]++;    });        return hist.map((count, i) => ({      value: min + (i + 0.5) * binWidth,      count: count    }));  };    // Draw a single sample  const drawSample = () => {    const sample = [];    for(let i = 0; i < sampleSize; i++) {      const randomIndex = Math.floor(Math.random() * population.length);      sample.push(population[randomIndex]);    }    const mean = sample.reduce((a, b) => a + b, 0) / sample.length;        setCurrentSample(sample);    setSampleMeans(prev => [...prev, mean]);    setNumSamples(prev => prev + 1);  };    // Animate drawing multiple samples  const drawMultipleSamples = async (count) => {    setIsAnimating(true);    for(let i = 0; i < count; i++) {      drawSample();      await new Promise(resolve => setTimeout(resolve, 100));    }    setIsAnimating(false);  };    // Reset everything  const reset = () => {    setSampleMeans([]);    setNumSamples(0);    setCurrentSample([]);  };    // Recalculate when population type changes  useEffect(() => {    reset();  }, [populationType, sampleSize]);    const sampleMeansMean = sampleMeans.length > 0     ? sampleMeans.reduce((a, b) => a + b, 0) / sampleMeans.length     : 0;    const sampleMeansStd = sampleMeans.length > 1    ? Math.sqrt(sampleMeans.reduce((sum, val) => sum + Math.pow(val - sampleMeansMean, 2), 0) / (sampleMeans.length - 1))    : 0;    const theoreticalSEM = popStd / Math.sqrt(sampleSize);    return (    <div className="w-full h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-6 overflow-auto">      <div className="max-w-7xl mx-auto">        <div className="text-center mb-6">          <h1 className="text-4xl font-bold text-indigo-900 mb-2">            Sampling Distribution Explorer          </h1>          <p className="text-lg text-indigo-700">            Watch the Central Limit Theorem in action!          </p>        </div>                {/* Controls */}        <div className="bg-white rounded-xl shadow-lg p-6 mb-6">          <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">            <div>              <label className="block text-sm font-semibold text-gray-700 mb-2">                Population Distribution              </label>              <select                 value={populationType}                onChange={(e) => setPopulationType(e.target.value)}                className="w-full p-2 border-2 border-indigo-200 rounded-lg focus:border-indigo-500 focus:outline-none"              >                <option value="normal">Normal</option>                <option value="uniform">Uniform</option>                <option value="skewed">Right-Skewed</option>                <option value="bimodal">Bimodal</option>              </select>            </div>                        <div>              <label className="block text-sm font-semibold text-gray-700 mb-2">                Sample Size (n = {sampleSize})              </label>              <input                 type="range"                 min="2"                 max="100"                 value={sampleSize}                onChange={(e) => setSampleSize(parseInt(e.target.value))}                className="w-full"              />            </div>                        <div>              <label className="block text-sm font-semibold text-gray-700 mb-2">                Samples Drawn: {numSamples}              </label>              <div className="flex gap-2">                <button                  onClick={drawSample}                  disabled={isAnimating}                  className="flex-1 bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 disabled:bg-gray-400 transition-colors font-semibold"                >                  Draw 1                </button>                <button                  onClick={() => drawMultipleSamples(10)}                  disabled={isAnimating}                  className="flex-1 bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 disabled:bg-gray-400 transition-colors font-semibold flex items-center justify-center gap-1"                >                  <Play size={16} /> 10                </button>                <button                  onClick={reset}                  disabled={isAnimating}                  className="bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700 disabled:bg-gray-400 transition-colors"                >                  <RotateCcw size={16} />                </button>              </div>            </div>          </div>                    {/* Statistics */}          <div className="grid grid-cols-2 md:grid-cols-4 gap-4 p-4 bg-indigo-50 rounded-lg">            <div className="text-center">              <div className="text-xs text-indigo-600 font-semibold">Population Mean</div>              <div className="text-xl font-bold text-indigo-900">{popMean.toFixed(2)}</div>            </div>            <div className="text-center">              <div className="text-xs text-indigo-600 font-semibold">Population SD</div>              <div className="text-xl font-bold text-indigo-900">{popStd.toFixed(2)}</div>            </div>            <div className="text-center">              <div className="text-xs text-purple-600 font-semibold">Sample Means Mean</div>              <div className="text-xl font-bold text-purple-900">                {sampleMeans.length > 0 ? sampleMeansMean.toFixed(2) : '--'}              </div>            </div>            <div className="text-center">              <div className="text-xs text-purple-600 font-semibold">Sample Means SD</div>              <div className="text-xl font-bold text-purple-900">                {sampleMeans.length > 1 ? `${sampleMeansStd.toFixed(2)}` : '--'}              </div>              <div className="text-xs text-purple-500">                Theory: {theoreticalSEM.toFixed(2)}              </div>            </div>          </div>        </div>                {/* Visualizations */}        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">          {/* Population Distribution */}          <div className="bg-white rounded-xl shadow-lg p-6">            <h2 className="text-xl font-bold text-indigo-900 mb-4">              Population Distribution (N = {populationSize})            </h2>            <ResponsiveContainer width="100%" height={300}>              <BarChart data={getPopulationHistogram()}>                <CartesianGrid strokeDasharray="3 3" />                <XAxis                   dataKey="value"                   tickFormatter={(val) => val.toFixed(0)}                  label={{ value: 'Value', position: 'insideBottom', offset: -5 }}                />                <YAxis label={{ value: 'Frequency (%)', angle: -90, position: 'insideLeft' }} />                <Tooltip formatter={(val) => val.toFixed(2) + '%'} />                <Bar dataKey="count" fill="#6366f1" />                <ReferenceLine x={popMean} stroke="#dc2626" strokeWidth={2} label="?" />              </BarChart>            </ResponsiveContainer>          </div>                    {/* Sampling Distribution */}          <div className="bg-white rounded-xl shadow-lg p-6">            <h2 className="text-xl font-bold text-purple-900 mb-4 flex items-center gap-2">              <Sparkles size={24} />              Sampling Distribution of the Mean            </h2>            {sampleMeans.length > 0 ? (              <ResponsiveContainer width="100%" height={300}>                <BarChart data={getSampleMeansHistogram()}>                  <CartesianGrid strokeDasharray="3 3" />                  <XAxis                     dataKey="value"                     tickFormatter={(val) => val.toFixed(1)}                    label={{ value: 'Sample Mean', position: 'insideBottom', offset: -5 }}                  />                  <YAxis label={{ value: 'Count', angle: -90, position: 'insideLeft' }} />                  <Tooltip formatter={(val) => val} />                  <Bar dataKey="count" fill="#9333ea" />                  <ReferenceLine x={popMean} stroke="#dc2626" strokeWidth={2} label="?" />                </BarChart>              </ResponsiveContainer>            ) : (              <div className="h-[300px] flex items-center justify-center text-gray-400">                <div className="text-center">                  <Sparkles size={48} className="mx-auto mb-2 opacity-30" />                  <p className="text-lg">Draw samples to see the magic happen!</p>                </div>              </div>            )}          </div>        </div>                {/* Key Insight */}        {sampleMeans.length > 30 && (          <div className="mt-6 bg-gradient-to-r from-purple-100 to-indigo-100 rounded-xl shadow-lg p-6 border-2 border-purple-300">            <h3 className="text-lg font-bold text-purple-900 mb-2">              ?? Central Limit Theorem in Action!            </h3>            <p className="text-purple-800">              Notice how the sampling distribution becomes approximately normal, regardless of the population's shape!               The mean of sample means ({sampleMeansMean.toFixed(2)}) approaches the population mean ({popMean.toFixed(2)}),               and the standard error ({sampleMeansStd.toFixed(2)}) is close to ?/Ãn = {theoreticalSEM.toFixed(2)}.            </p>          </div>        )}      </div>    </div>  );};export default SamplingDistributionViz;